{\rtf1\ansi\ansicpg1252\cocoartf2822
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 AREA RESET, DATA, READONLY\
	EXPORT __Vectors\
	\
__Vectors\
	DCD 0x40001000\
	DCD Reset_Handler\
	\
	ALIGN\
	AREA mycode, CODE, READONLY\
	ENTRY\
	EXPORT Reset_Handler\
	\
Reset_Handler\
	LDR R0, =SRC        ; R0 = address of SRC\
    LDR R1, [R0]        ; R1 = value from SRC (e.g., 0x2D)\
    LDR R2, =RESULT     ; R2 = address of RESULT\
    \
    MOV R3, #0          ; R3 will hold the final BCD result\
    MOV R6, #0          ; R6 is the bit-shift counter, starts at 0\
    MOV R10, #10        ; Constant for division\
	\
UP\
	; Divide the number by 10\
	UDIV R4, R1, R10    ; R4 = Quotient (R1 / 10)\
	\
	; Find the remainder, which is our BCD digit\
	MLS R5, R10, R4, R1 ; R5 = Remainder (R1 - (10 * R4))\
	\
	; Shift the digit to the correct BCD position (0, 4, 8, etc.)\
	LSL R5, R5, R6\
	\
	; Combine the shifted digit into our final result\
	ORR R3, R3, R5\
	\
	ADD R6, R6, #4      ; Increment shift for the next digit\
	MOV R1, R4          ; The new number is the quotient from the division\
	\
	CMP R1, #0          ; Check if there are any digits left\
	BNE UP              ; If not zero, loop again\
	\
	STR R3, [R2]        ; Store the final BCD result\
	\
STOP\
	B STOP\
	\
	AREA mydata, DATA, READWRITE\
SRC DCD 0x0000002D      ; Input: Hex number (45 decimal)\
RESULT DCD 0\
	END}